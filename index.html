<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>Lighting Compare - Pixel Perfect</title>

<style>
/* 基础布局：强制全屏并禁止滚动 */
html,body{
  margin:0;
  height:100%;
  background:#111;
  overflow:hidden;
  font-family:system-ui;
}

#viewer{
  position:relative;
  width:100%;
  height:100%;
  overflow: hidden;
}

/* 图层基础样式：使用 clip-path 实现斜向切割效果 */
.layer{
  position:absolute;
  inset:0;
  background-size:cover;
  background-position:center;
  cursor:pointer;
  will-change: clip-path;
}

/* 装饰性分割线：对应图层边缘的视觉反馈线 */
.split-line {
  position: absolute;
  height: 2px;
  background-color: rgba(255, 255, 255, 0.6);
  box-shadow: 0 0 4px rgba(0,0,0,0.5);
  z-index: 5;
  transform-origin: top left;
  pointer-events: none;
}

/* 状态控制：页面加载完成后启用过渡动画 */
.asm-ready .layer, 
.asm-ready .split-line {
  transition: all .5s cubic-bezier(0.4, 0, 0.2, 1);
}

/* 动画运行期间禁用交互 */
body.is-animating .layer {
  cursor: none; 
}

/* 标签容器：倾斜展示文本 */
.label {
  position: absolute;
  color: #fff;
  font-style: italic;
  opacity: 0.9;
  text-shadow: 4px 1px 2px rgba(0,0,0,0.9);
  white-space: nowrap;
  letter-spacing: 2px;
  transform: rotate(70deg);
  transform-origin: top left;
  pointer-events: none;
  z-index: 10;
  display: flex;
  align-items: flex-end; 
}

/* 标签字符进场效果：定义单个字符的初始状态 */
.label span {
  display: block;
  opacity: 0;
  transform: scale(0.3) translateY(20px) translateZ(0);
  padding: 0 1px;
  will-change: transform, opacity;
  /* 使用弹性贝塞尔曲线实现回弹感 */
  transition: 
    opacity 0.4s ease-out, 
    transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1.2);
}

/* 激活状态：标签显示时字符弹出 */
.label:not(.hidden) span {
  opacity: 1;
  transform: scale(1) translateY(0) translateZ(0);
}

/* 离场状态：区块展开时标签快速隐去 */
.label.hidden {
  opacity: 0;
  transition: opacity 0.1s linear; 
}

.label.hidden span {
  opacity: 0;
  transform: scale(0.8) translateY(-5px) translateZ(0);
  transition: none !important; 
}

/* 自定义跟随鼠标：显示等待/状态提示 */
#custom-cursor {
  position: fixed;
  top: 0; left: 0;
  color: #fff;
  font-size: 24px;
  font-weight: bold;
  pointer-events: none;
  z-index: 100;
  opacity: 0;
  transition: opacity 0.15s;
  text-shadow: 0 0 10px rgba(0,0,0,0.8);
  display: flex;
  align-items: center;
  will-change: transform;
}

/* 仅在交互动画期间显示跟随鼠标 */
body.is-animating #custom-cursor { opacity: 1; }
.dots::after { content: ''; animation: dot-anim 1.5s infinite; }
@keyframes dot-anim { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }
</style>
</head>

<body>

<div id="viewer">
  <div class="layer" style="background-image:url(layer1.png); background-color:#333;"></div>
  <div class="layer" style="background-image:url(layer2.png); background-color:#444;"></div>
  <div class="layer" style="background-image:url(layer3.png); background-color:#555;"></div>
  <div class="layer" style="background-image:url(layer4.png); background-color:#666;"></div>
  
  <div class="split-line"></div>
  <div class="split-line"></div>
  <div class="split-line"></div>

  <div class="label" style="top:1.5%; left:17.5%;">灯光点位</div>
  <div class="label" style="top:1.5%; left:42.5%;">白模</div>
  <div class="label" style="top:1.5%; left:67.5%;">白模灯光</div>
</div>

<div id="custom-cursor"><span class="dots"></span></div>

<script>
/**
 * 核心逻辑说明：
 * 1. 初始状态：页面被平分为 4 个带斜率的区块。
 * 2. 交互状态：点击某个区块，该区块通过 clip-path 算法向左右推开其他区块，实现全屏展示。
 * 3. 视觉补偿：offset 变量决定了分割线的倾斜角度（水平位移量）。
 */

const layers = document.querySelectorAll(".layer");
const labels = document.querySelectorAll(".label");
const lines = document.querySelectorAll('.split-line');
const customCursor = document.getElementById('custom-cursor');

let focus = null;         // 当前激活的图层索引
let isAnimating = false;  // 动画状态锁
const defaultLines = [18, 43, 68]; // 初始分割线百分比位置
const offset = 15;        // 斜向切割的水平偏移量

// 文本处理：将标签文字拆分为单个 span 以实现逐字动画
labels.forEach(label => {
    const text = label.innerText;
    label.innerText = '';
    [...text].forEach((char, i) => {
        const span = document.createElement('span');
        span.innerText = char;
        // 根据字符索引设置错峰延迟
        span.style.transitionDelay = `${0.3 + (i * 0.04)}s`;
        label.appendChild(span);
    });
});

// 鼠标跟随更新
function updateCursor(e) {
    customCursor.style.transform = `translate3d(${e.clientX - 10}px, ${e.clientY - 25}px, 0)`;
}
window.addEventListener('mousemove', updateCursor);

/**
 * 渲染函数：计算并应用所有图层的路径和线位置
 */
function render() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  let lineTargets = [];

  // 计算目标位置：常规态或聚焦态
  if (focus === null) {
    lineTargets = [...defaultLines];
  } else {
    // 聚焦时，左侧线推向左边缘，右侧线推向右边缘
    const leftBase = -60; 
    const rightBase = 140;
    const step = 10; 
    lineTargets = defaultLines.map((_, index) => {
      if (index < focus) return leftBase + (index * step);
      else return rightBase + (index * step);
    });
  }

  // 关键边界计算：[左边缘, 分割线1, 分割线2, 分割线3, 右边缘]
  const boundaries = [0, ...lineTargets, 100];

  // 应用图层裁剪路径
  layers.forEach((l, i) => {
    let x1 = boundaries[i], x2 = boundaries[i+1], x3 = x2 + offset, x4 = x1 + offset;
    
    // 边界溢出修正：确保首尾图层覆盖全屏
    const finalX1 = (i === 0) ? Math.min(x1, 0) : x1;
    const finalX4 = (i === 0) ? Math.min(x4, 0) : x4;
    const finalX2 = (i === layers.length - 1) ? Math.max(x2, 100) : x2;
    const finalX3 = (i === layers.length - 1) ? Math.max(x3, 100 + offset) : x3;
    
    l.style.clipPath = `polygon(${finalX1}% 0%, ${finalX2}% 0%, ${finalX3}% 100%, ${finalX4}% 100%)`;
  });

  // 应用分割线：计算斜线长度及旋转角度
  lines.forEach((line, i) => {
    const tx = lineTargets[i];
    const px_x1 = (tx / 100) * width, px_x2 = ((tx + offset) / 100) * width;
    const deltaX = px_x2 - px_x1, deltaY = height;
    const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
    
    line.style.width = `${length}px`;
    line.style.left = `${px_x1}px`;
    line.style.transform = `rotate(${angle}deg)`;
  });

  // 控制标签显隐
  labels.forEach(l => {
    focus === null ? l.classList.remove("hidden") : l.classList.add("hidden");
  });
}

// 监听过渡结束：重置动画锁和状态
layers[0].addEventListener('transitionend', (e) => {
  if (e.propertyName === 'clip-path') {
    isAnimating = false;
    document.body.classList.remove('is-animating');
  }
});

// 初始化渲染
render();

// 延迟启动动画类，确保首次进入无闪烁过渡
requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    document.body.classList.add('asm-ready');
  });
});

window.addEventListener('resize', render);

// 图层点击交互逻辑
layers.forEach((layer, i) => {
  layer.onclick = (e) => {
    if (isAnimating) return; 
    
    updateCursor(e);
    const targetFocus = (focus === i) ? null : i; // 再次点击已激活图层则还原
    isAnimating = true;
    document.body.classList.add('is-animating');
    focus = targetFocus;
    render();
  };
});
</script>

</body>
</html>
