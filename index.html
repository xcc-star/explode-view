<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>Lighting Compare - Pixel Perfect</title>

<style>
html,body{
  margin:0;
  height:100%;
  background:#111;
  overflow:hidden;
  font-family:system-ui;
}

#viewer{
  position:relative;
  width:100%;
  height:100%;
  overflow: hidden;
}

.layer{
  position:absolute;
  inset:0;
  background-size:cover;
  background-position:center;
  cursor:pointer;
  will-change: clip-path;
}

.split-line {
  position: absolute;
  height: 2px;
  background-color: rgba(255, 255, 255, 0.6);
  box-shadow: 0 0 4px rgba(0,0,0,0.5);
  z-index: 5;
  transform-origin: top left;
  pointer-events: none;
}

.asm-ready .layer, 
.asm-ready .split-line {
  transition: all .5s cubic-bezier(0.4, 0, 0.2, 1);
}

body.is-animating .layer {
  cursor: none; 
}

/* 标签样式重构 */
.label {
  position: absolute;
  color: #fff;
  font-style: italic;
  opacity: 0.9;
  text-shadow: 0 2px 8px rgba(0,0,0,0.8);
  white-space: nowrap;
  letter-spacing: 2px;
  
  /* 强制还原旋转位置 */
  transform: rotate(70deg);
  transform-origin: top left;
  pointer-events: none;
  z-index: 10;

  /* 使用 Flex 布局强制对齐，彻底解决高低不平 */
  display: flex;
  align-items: flex-end; /* 强制底部对齐 */
}

/* 逐字 span 样式重构 */
.label span {
  display: block;
  opacity: 1;
  /* 解决斜体溢出导致的视觉切断感 */
  padding: 0 1px;
  /* 改变动画方式：从位移改为缩放，避免亚像素位移导致的高低感 */
  transform: scale(1) translateZ(0); 
  will-change: transform, opacity;
  transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.2);
}

/* 离场状态 */
.label.hidden {
  opacity: 0;
  transition: opacity 0.1s linear; 
}

.label.hidden span {
  opacity: 0;
  /* 离场时快速缩小 */
  transform: scale(0.8) translateZ(0);
  transition: none !important; 
}

/* 鼠标跟随省略号 */
#custom-cursor {
  position: fixed;
  top: 0; left: 0;
  color: #fff;
  font-size: 24px;
  font-weight: bold;
  pointer-events: none;
  z-index: 100;
  opacity: 0;
  transition: opacity 0.15s;
  text-shadow: 0 0 10px rgba(0,0,0,0.8);
  display: flex;
  align-items: center;
  will-change: transform;
}
body.is-animating #custom-cursor { opacity: 1; }
.dots::after { content: ''; animation: dot-anim 1.5s infinite; }
@keyframes dot-anim { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }
</style>
</head>

<body>

<div id="viewer">
  <div class="layer" style="background-image:url(layer1.png); background-color:#333;"></div>
  <div class="layer" style="background-image:url(layer2.png); background-color:#444;"></div>
  <div class="layer" style="background-image:url(layer3.png); background-color:#555;"></div>
  <div class="layer" style="background-image:url(layer4.png); background-color:#666;"></div>
  
  <div class="split-line"></div>
  <div class="split-line"></div>
  <div class="split-line"></div>

  <div class="label" style="top:1.5%; left:17.5%;">灯光点位</div>
  <div class="label" style="top:1.5%; left:42.5%;">白模</div>
  <div class="label" style="top:1.5%; left:67.5%;">白模灯光</div>
</div>

<div id="custom-cursor"><span class="dots"></span></div>

<script>
const layers = document.querySelectorAll(".layer");
const labels = document.querySelectorAll(".label");
const lines = document.querySelectorAll('.split-line');
const customCursor = document.getElementById('custom-cursor');

let focus = null;
let isAnimating = false; 
const defaultLines = [18, 43, 68]; 
const offset = 15; 

// 逐字初始化逻辑
labels.forEach(label => {
    const text = label.innerText;
    label.innerText = '';
    [...text].forEach((char, i) => {
        const span = document.createElement('span');
        span.innerText = char;
        // 进场延迟设置
        span.style.transitionDelay = `${0.4 + (i * 0.04)}s`;
        label.appendChild(span);
    });
});

function updateCursor(e) {
    customCursor.style.transform = `translate3d(${e.clientX - 10}px, ${e.clientY - 25}px, 0)`;
}
window.addEventListener('mousemove', updateCursor);

function render() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  let lineTargets = [];

  if (focus === null) {
    lineTargets = [...defaultLines];
  } else {
    const leftBase = -60; 
    const rightBase = 140;
    const step = 10; 
    lineTargets = defaultLines.map((_, index) => {
      if (index < focus) return leftBase + (index * step);
      else return rightBase + (index * step);
    });
  }

  const boundaries = [0, ...lineTargets, 100];

  layers.forEach((l, i) => {
    let x1 = boundaries[i], x2 = boundaries[i+1], x3 = x2 + offset, x4 = x1 + offset;
    const finalX1 = (i === 0) ? Math.min(x1, 0) : x1;
    const finalX4 = (i === 0) ? Math.min(x4, 0) : x4;
    const finalX2 = (i === layers.length - 1) ? Math.max(x2, 100) : x2;
    const finalX3 = (i === layers.length - 1) ? Math.max(x3, 100 + offset) : x3;
    l.style.clipPath = `polygon(${finalX1}% 0%, ${finalX2}% 0%, ${finalX3}% 100%, ${finalX4}% 100%)`;
  });

  lines.forEach((line, i) => {
    const tx = lineTargets[i];
    const px_x1 = (tx / 100) * width, px_x2 = ((tx + offset) / 100) * width;
    const deltaX = px_x2 - px_x1, deltaY = height;
    const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
    line.style.width = `${length}px`;
    line.style.left = `${px_x1}px`;
    line.style.transform = `rotate(${angle}deg)`;
  });

  labels.forEach(l => {
    focus === null ? l.classList.remove("hidden") : l.classList.add("hidden");
  });
}

layers[0].addEventListener('transitionend', (e) => {
  if (e.propertyName === 'clip-path') {
    isAnimating = false;
    document.body.classList.remove('is-animating');
  }
});

render();
requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    document.body.classList.add('asm-ready');
  });
});
window.addEventListener('resize', render);

layers.forEach((layer, i) => {
  layer.onclick = (e) => {
    if (isAnimating) return; 
    updateCursor(e);
    const targetFocus = (focus === i) ? null : i;
    isAnimating = true;
    document.body.classList.add('is-animating');
    focus = targetFocus;
    render();
  };
});
</script>

</body>
</html>
