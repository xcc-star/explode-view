<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>Lighting Compare - Responsive Perfect</title>

<style>
/**
 * 基础容器与全局重置
 * 确保视图全屏、无滚动条，并优化系统字体渲染
 */
html, body {
  margin: 0;
  height: 100%;
  background: #111;
  overflow: hidden;
  font-family: system-ui, -apple-system, sans-serif;
}

#viewer {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

/**
 * 核心图层样式
 * will-change 优化浏览器渲染层合成，平滑处理 clip-path 路径变换
 */
.layer {
  position: absolute;
  inset: 0;
  background-size: cover;
  background-position: center;
  cursor: pointer;
  will-change: clip-path;
}

/**
 * 分割线装饰
 * 轴心设为 top left 以匹配 JS 计算的几何坐标原点
 */
.split-line {
  position: absolute;
  height: 2px;
  background-color: rgba(255, 255, 255, 0.6);
  box-shadow: 0 0 4px rgba(0,0,0,0.5);
  z-index: 5;
  transform-origin: top left;
  pointer-events: none;
}

/**
 * 过渡效果状态机控制
 * .asm-ready: 初始进入场景的标志
 * .no-transition: 窗口 Resize 等高性能响应场景下禁用平滑过渡
 */
.asm-ready:not(.no-transition) .layer, 
.asm-ready:not(.no-transition) .split-line,
.asm-ready:not(.no-transition) .label {
  transition: all .5s cubic-bezier(0.4, 0, 0.2, 1);
}

.no-transition * {
  transition: none !important;
}

body.is-animating .layer {
  cursor: none; 
}

/**
 * 动态文本标签容器布局
 */
.label {
  position: absolute;
  color: #fff;
  font-style: italic;
  opacity: 0.9;
  text-shadow: 4px 1px 2px rgba(0,0,0,0.9);
  white-space: nowrap;
  letter-spacing: 2px;
  transform-origin: top left;
  pointer-events: none;
  z-index: 10;
  display: flex;
  align-items: flex-end;
}

/**
 * 标签字符级联动画
 */
.label span {
  display: block;
  opacity: 0;
  transform: scale(0.3) translateY(20px) translateZ(0);
  padding: 0 1px;
  will-change: transform, opacity;
  transition: 
    opacity 0.4s ease-out, 
    transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1.2);
}

/* 标签可见激活状态 */
.label:not(.hidden) span {
  opacity: 1;
  transform: scale(1) translateY(0) translateZ(0);
}

/* 标签区块隐藏状态（点击交互触发） */
.label.hidden {
  opacity: 0;
  transition: opacity 0.1s linear; 
}

.label.hidden span {
  opacity: 0;
  transform: scale(0.8) translateY(-5px) translateZ(0);
  transition: none !important; 
}

/**
 * 交互反馈指示器（自定义鼠标跟随）
 */
#custom-cursor {
  position: fixed;
  top: 0; left: 0;
  color: #fff;
  font-size: 24px;
  font-weight: bold;
  pointer-events: none;
  z-index: 100;
  opacity: 0;
  transition: opacity 0.15s;
  text-shadow: 0 0 10px rgba(0,0,0,0.8);
  display: flex;
  align-items: center;
  will-change: transform;
}
body.is-animating #custom-cursor { opacity: 1; }
.dots::after { content: ''; animation: dot-anim 1.5s infinite; }
@keyframes dot-anim { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }
</style>
</head>

<body>

<div id="viewer">
  <div class="layer" style="background-image:url(layer1.png); background-color:#333;"></div>
  <div class="layer" style="background-image:url(layer2.png); background-color:#444;"></div>
  <div class="layer" style="background-image:url(layer3.png); background-color:#555;"></div>
  <div class="layer" style="background-image:url(layer4.png); background-color:#666;"></div>
  
  <div class="split-line"></div>
  <div class="split-line"></div>
  <div class="split-line"></div>

  <div class="label" style="top:1.5%; left:17.5%;">灯光点位</div>
  <div class="label" style="top:1.5%; left:42.5%;">白模</div>
  <div class="label" style="top:1.5%; left:67.5%;">白模灯光</div>
</div>

<div id="custom-cursor"><span class="dots"></span></div>

<script>
/**
 * 核心配置常量
 */
const layers = document.querySelectorAll(".layer");
const labels = document.querySelectorAll(".label");
const lines = document.querySelectorAll('.split-line');
const customCursor = document.getElementById('custom-cursor');

let focus = null;          // 当前聚焦图层索引
let isAnimating = false;   // 交互动画锁
let resizeTimer;           // 视口调整防抖计时器
const defaultLines = [18, 43, 68]; // 默认分割线百分比位置
const offset = 15;                // 斜切水平偏移常量 (%)

/**
 * 文本节点初始化：将字符串转换为支持级联过渡动画的 span 序列
 */
labels.forEach(label => {
    const text = label.innerText;
    label.innerText = '';
    [...text].forEach((char, i) => {
        const span = document.createElement('span');
        span.innerText = char;
        span.style.transitionDelay = `${0.3 + (i * 0.04)}s`;
        label.appendChild(span);
    });
});

/**
 * 鼠标跟随逻辑更新
 */
function updateCursor(e) {
    customCursor.style.transform = `translate3d(${e.clientX - 10}px, ${e.clientY - 25}px, 0)`;
}
window.addEventListener('mousemove', updateCursor);

/**
 * 主渲染函数：计算几何布局、裁剪路径与 UI 元素对齐
 */
function render() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  let lineTargets = [];

  // 1. 根据当前聚焦状态计算分割线目标位置
  if (focus === null) {
    lineTargets = [...defaultLines];
  } else {
    const leftBase = -60, rightBase = 140, step = 10; 
    lineTargets = defaultLines.map((_, index) => 
      (index < focus) ? leftBase + (index * step) : rightBase + (index * step)
    );
  }

  // 2. 动态斜率计算：确保分割线与标签文字在任意视口比例下保持平行
  const deltaX_px = (offset / 100) * width;
  const angleDeg = Math.atan2(height, deltaX_px) * 180 / Math.PI;

  const boundaries = [0, ...lineTargets, 100];

  // 3. 应用图层裁剪路径 (Polygon Clip-path)
  layers.forEach((l, i) => {
    let x1 = boundaries[i], x2 = boundaries[i+1], x3 = x2 + offset, x4 = x1 + offset;
    
    // 边界溢出修正，确保极值情况下图层覆盖完整
    const finalX1 = (i === 0) ? Math.min(x1, 0) : x1;
    const finalX4 = (i === 0) ? Math.min(x4, 0) : x4;
    const finalX2 = (i === layers.length - 1) ? Math.max(x2, 100) : x2;
    const finalX3 = (i === layers.length - 1) ? Math.max(x3, 100 + offset) : x3;
    
    l.style.clipPath = `polygon(${finalX1}% 0%, ${finalX2}% 0%, ${finalX3}% 100%, ${finalX4}% 100%)`;
  });

  // 4. 同步分割线与标签的几何姿态
  lines.forEach((line, i) => {
    const tx = lineTargets[i];
    const px_x1 = (tx / 100) * width;
    const length = Math.sqrt(deltaX_px * deltaX_px + height * height);
    
    line.style.width = `${length}px`;
    line.style.left = `${px_x1}px`;
    line.style.transform = `rotate(${angleDeg}deg)`;

    if (labels[i]) {
      labels[i].style.transform = `rotate(${angleDeg}deg)`;
    }
  });

  // 5. 交互状态下的 UI 显隐逻辑控制
  labels.forEach(l => {
    focus === null ? l.classList.remove("hidden") : l.classList.add("hidden");
  });
}

/**
 * 响应式布局优化：
 * 监听 resize 期间挂起动画过渡，确保视觉表现与容器缩放同步。
 */
window.addEventListener('resize', () => {
  document.body.classList.add('no-transition');
  render();

  // 防抖处理：停止缩放 100ms 后恢复平滑过渡
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    document.body.classList.remove('no-transition');
  }, 100);
});

/**
 * 过渡状态监听：当路径裁剪动画完成后释放动画锁
 */
layers[0].addEventListener('transitionend', (e) => {
  if (e.propertyName === 'clip-path') {
    isAnimating = false;
    document.body.classList.remove('is-animating');
  }
});

/**
 * 入口初始化与首帧动画触发
 */
render();
requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    document.body.classList.add('asm-ready');
  });
});

/**
 * 交互事件绑定：图层点击切换聚焦态
 */
layers.forEach((layer, i) => {
  layer.onclick = (e) => {
    if (isAnimating) return; 
    
    updateCursor(e);
    focus = (focus === i) ? null : i;
    isAnimating = true;
    document.body.classList.add('is-animating');
    render();
  };
});
</script>

</body>
</html>
